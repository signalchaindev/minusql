!function(e){function t(e){try{return[JSON.parse(e),null]}catch(t){return[e,t]}}const r=e=>null==e||e.constructor===Array&&0===e.length||e.constructor===Object&&0===Object.keys(e).length||e.constructor===String&&0===e.trim().length,s=new Map;function o({uri:e,credentials:t,headers:s,requestOptions:o,verbose:n}){this.uri=e,this.requestObject={method:"POST",headers:{Accept:"application/json","Content-Type":"application/json",...s},credentials:t||"include"},r(o)||(this.requestObject.requestOptions=o),n&&(this.verbose=n)}function n(e,t=!0,r={}){if(t||this.verbose&&console.error(`${e} method requires an object argument with a '${e}' property`),0!==Object.keys(r).length)for(const e of Object.keys(r))this.verbose&&console.error(`Error: ${e} is not a valid option`)}function i(e,t,s,o){const n={operation:e,variables:t};return r(s)||(n.requestOptions=s),r(o)||(n.refetchQuery=o),n}o.prototype.query=function({query:e,variables:t,requestOptions:r,...s}){n("query",!!e,s);const o=i(e,t,r);return this.fetchHandler(o)},o.prototype.mutation=function({mutation:e,variables:t,refetchQuery:r=null,requestOptions:s,...o}){n(o),n("mutation",!!e,o);const a=i(e,t,s,r);return this.fetchHandler(a)},o.prototype.cache=function({operation:e,operationName:t,variables:r,refetchQuery:o,requestOptions:n,data:i,updateItem:a,deleteItem:c}){let l;!e||a||c||(l=JSON.stringify({query:o?o.query:t,variables:o?o.variables:r}));const u={operation:e,variables:r,requestOptions:n};if(o||!i){if(l&&!o&&!a&&!c){return s.get(l)}if(o){const e=JSON.stringify(o),{options:t}=s.get(e);return s.delete(e),void this.fetchHandler(t)}if(a){const{data:e,...t}=a,r=JSON.stringify(t),o=s.get(r),n=o&&o.options;return s.set(r,{data:e,options:n}),s}if(c){const e=JSON.stringify(c);return s.has(e)&&s.delete(e),s}return s.size>0?s:void 0}s.set(l,{...i,options:u})},o.prototype.fetchHandler=async function({operation:e,variables:r,refetchQuery:s=null,requestOptions:o}){const[n,i]=e.split(" "),[a]=i.split("("),c="query"===n;if("mutation"===n&&s&&await this.cache({refetchQuery:s}),c){const t=await this.cache({operation:e,operationName:a,variables:r,requestOptions:o});if(t)return{...t,error:null}}const l={operationName:a,query:e,variables:r},u={...this.requestObject,...o,body:JSON.stringify(l)};let h={};const p=await fetch(this.uri,u).catch(e=>{this.verbose&&console.error(e),h={message:e,stack:null,details:null}});if(!p)return{data:null,error:{message:"Request failed"}};const f=await p.json().catch(e=>{this.verbose&&console.error(e),h={message:e,stack:null,details:null}});if(!f)return{data:null,error:{message:h.message}};if(h={message:p.statusText,stack:p,details:f&&f.errors},f||(h.details=[...h.details,{message:"Bad Response: "+(f||null)}]),Object.keys(f).every(e=>!f[e])&&(h.details=[...h.details,{message:"Bad Response: "+(f||null)}]),!p.ok||f&&f.errors&&0!==f.errors.length){const e={};this.verbose&&console.error("Error:",h);for(const r of f.errors){const[s]=t(r.message);if("string"==typeof s)"[object Object]"===s&&this.verbose&&console.error("Error: thrown errors must be of type string"),this.verbose&&console.error("Error: "+s),e.message=s;else for(const[t,r]of Object.entries(s))this.verbose&&console.error(`Error: "${t}: ${r}"`),e[t]=r}return{data:null,error:Object.keys(e).length>0?e:null}}return c&&await this.cache({operation:e,variables:r,data:f}),{...f.data,error:p.ok&&null}},e.MinusQL=o,e.gql=function(e,...t){return String.raw({raw:(r=e[0],r.replace(/[\s,]+/g," ").trim())},...t);var r}}({});
